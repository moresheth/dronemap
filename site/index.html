<!DOCTYPE html>
<html lang="en">
<head>

	<title>DroneMap</title>
	<meta charset="utf-8">
	<meta name="description" content="Mapping an area in 3D using AR Drone and ultrasonic sensors.">

<!--[if lt IE 9]>
<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->

<style>
body {
    background-color: #050505;
    margin: 0px;
    overflow: hidden;
}
</style>

</head>
<body>
<div id="container"></div>
<!-- <script src="//drone:8080/socket.io/socket.io.js"></script> -->
<script src="three.min.js"></script>
<script src="Detector.js"></script>
<script src="testdata.js"></script>
<script>

//var socket = io.connect('http://drone:8080/');

//socket.on('points', socketPoints);

function socketPoints(data) {
    console.log(data);
}

// Adapted from this demo:
// http://mrdoob.github.com/three.js/examples/webgl_particles_random.html
if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

var container,
    camera,
    scene,
    renderer,
    particles,
    geometry,
    material,
    parameters,
    i,
    h,
    color,
    mouseX = 0,
    mouseY = 0,
    mult = 1.5,
    windowHalfX = window.innerWidth / 2,
    windowHalfY = window.innerHeight / 2;

init();
animate();
loadTestData();

function loadTestData() {

    for (var i=0,l=testdata.length;i<l;i++) {
        for (var j=0,k=testdata[i].length;j<k;j++) {
            var dot = testdata[i][j];

            var vertex = new THREE.Vector3();
            vertex.x = dot[0] * mult;
            vertex.y = dot[1] * mult;
            vertex.z = dot[2] * mult;

            geometry.vertices.push( vertex );
        }
    }


    //geometry.verticesNeedUpdate = true;
    geometry.__dirtyVertices = true;
}

function init() {

    container = document.createElement( 'div' );
    document.body.appendChild( container );

    camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 3000 );
    camera.position.z = 800;

    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2( 0x000000, 0.0007 );

    geometry = new THREE.Geometry();

    for (var i=0,l=testdata.length;i<l;i++) {
        for (var j=0,k=testdata[i].length;j<k;j++) {
            var dot = testdata[i][j];

            var vertex = new THREE.Vector3();
            vertex.x = dot[0] * mult;
            vertex.y = dot[1] * mult;
            vertex.z = dot[2] * mult;

            geometry.vertices.push( vertex );
        }
    }

    material = new THREE.ParticleBasicMaterial( { size: 5 } );
    material.color.setHSV( 1.0, 1.0, 1.0 );

    particles = new THREE.ParticleSystem( geometry, material );

    scene.add( particles );

    renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
    container.appendChild( renderer.domElement );

    document.addEventListener( 'mousemove', onDocumentMouseMove, false );
    document.addEventListener( 'touchstart', onDocumentTouchStart, false );
    document.addEventListener( 'touchmove', onDocumentTouchMove, false );

    window.addEventListener( 'resize', onWindowResize, false );

}

function onWindowResize() {

    windowHalfX = window.innerWidth / 2;
    windowHalfY = window.innerHeight / 2;

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );

}

function onDocumentMouseMove( event ) {

    mouseX = event.clientX - windowHalfX;
    mouseY = event.clientY - windowHalfY;

}

function onDocumentTouchStart( event ) {

    if ( event.touches.length === 1 ) {

        event.preventDefault();

        mouseX = event.touches[ 0 ].pageX - windowHalfX;
        mouseY = event.touches[ 0 ].pageY - windowHalfY;

    }

}

function onDocumentTouchMove( event ) {

    if ( event.touches.length === 1 ) {

        event.preventDefault();

        mouseX = event.touches[ 0 ].pageX - windowHalfX;
        mouseY = event.touches[ 0 ].pageY - windowHalfY;

    }

}

//

function animate() {

    requestAnimationFrame( animate );

    render();

}

function render() {

    var time = Date.now() * 0.00005;

    camera.position.x += ( mouseX - camera.position.x ) * 0.05;
    camera.position.y += ( - mouseY - camera.position.y ) * 0.05;

    camera.lookAt( scene.position );

    renderer.render( scene, camera );

}

</script>
</body>
</html>
